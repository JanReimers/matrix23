Design objectives:
    1) Start with zero based indexing
        Add in FORTRAN 1 based (or arbitrary lower bounds) indexing.  Do this last so that all the internal work is done with zero
        based indexing.
    2) This allows us to use size_t for all indexing integers
    3) Support the same matrix packing arrangements used by Lapack and Blas for full, triangular (U/L), band, tri-diagonal and diagonal matrices.
        Done: Isolate all the packing and unpacking code into a isPacker and isShaper concepts and groups of classes.
        Deon: The subscriptor really has two aspects:
            1) The shape which determines which indexes (i,j) are assumed to zero (regardes of weather or not those zeros are actually stored).
            2) The packing determines arrangements of the elements.  i.e. how (i,j) are layed in linear memory.
        Usually packing follows from shape.  But Lapack and Blas support for example triangular shape with full storage.  i.e. part of matrix is allocated
        but unused.  There must be reasons for this.  Program complexity may be one of them.
        For each type we have a virtual size nr*nc and a packed size.  Packed size is probably only needed for data array construction.
    4) Support symmetric and Hermitian symmetries using triangular packing.
        This adds a third aspect to matrix storage, symmetry.  
        only a certain subset of combinations make sense.  Each of these three aspects would have and agent in the Matrix class that does the required work.
    5) Use std::vector<T> and std::valarray<T> interchangably for storing the raw data.  
        Also support a Copy-On-Write array?
    6) Support overloaded operators with lazy (delayed) evaluation
        As much as possible use ranges and view adaptors instead of traditional expression templates to achieve lazy evaluation.
        Matrix*Matrix should take advantage packing type.  For example DiagonalMatrix * DiagonalMatrix is O(N) not O(N^3)!
    7) Support float, double, std::complex<T> data types.
    8) Support various initialization type: none, zero, one, value, diagonal, random, randompos
    9) Use c++23.  Huge convenience of zip, zip_transform view adaptors.
    10) Make some blasmm(Matrix,Matrix) functions for speed comparison
    11) Support ascii/binary io with the cereal header library.
    12) No traditional for loops like:  for (size_t i = 0; i < nrows; ++i)
    13) No new/delete
        
Issues:
    -Still need to add symmetry
    -What are the rules for propagating Indexing (col/row major) through a matrix product?
        At the moment We don't even store the attribute.
        Using lambdas for row/col major indexing is a little sketchy.
        Also we need mirror image row(i)/col(j) implementations for row/col major indexing.  More lambdas?
            or throw in the towel and make distincte FullPackerRM, FullPackerCM classes? 
    Fixed: -Lots of duplication with nr/nc when creating packers and shapers.
    -Can we have packer.create_shaper(); to avoid all the Shaper pair rules?
    -Move default op(i,j) based row(i)/col(j) in the PackerCommon
        Then make efficient override for full matrix using chunk & stride view adaptors.
        These overrides need to know the Indexing option.
    -Clean up files.  exentsion hpp sux
    -The performance M*M is absolutely terrible compared to blas::dgemm
        blas is very hard to match :https://stackoverflow.com/questions/1303182/how-does-blas-get-such-extreme-performance
        -Make a simple op(i,j) version to compare
            Results for n=300:
                blas: 5100us
                opij no packer: 25200us
                opij with packer: 24500us
                ranges: 25300
                ranges + remove all opt for CM rows/cols: 24400us
        -Take away message:
            Even the dummbest (but cleanest) ranges code is just fine compared to hand coded
            Think of a clean way to allow user to opt for the blas call.
                1) global flag  matrix23::blas_on()/blas_off()
                    put and if statement in op*(M,M)
                2) op*(M,M) always does ranges. user must choose for hot code ares: blasmm(M,M), blasmv(M,V), blasvm(V,M) 
                    Construct of temporaries for chained calles.  No way to avoid that.
                





        -Make a simple full matrix CM sample class and add some range functionaly bit by bit to see where performance drops.

-Numerous overloaded operators (+ - *scalar etc) for Vector return a VectorView<std::ranges::viewable_range R>
 where R varies depending on oporator history. We return VectorView instead of viewable_range so that all operators
 only got called for isVector arguments.
 Since these are all 1D operations, It would nice to use the same overloaded ops for Matrix + Matrix.  But then they need to return
 a MatrixView instead of a VectorView.  On idea is for Matrix and MatrixView to define a type view_t = MatrixView<R>
 but matrix does not know R it just knows template <std::ranges::viewable_range R> MatrixView

 - op+(isVector a, isVector b) should calculate the union of the a.indices and b.indices, thus skipping over zeros (a[i]==0 && b[i]==0)

 -Fortran storage:
 
      real A(3,5)
defines a two-dimensional array of 3*5=15 real numbers. It is useful to think of the first index as the row index, and the second as the column index. Hence we get the graphical picture:

   (1,1)  (1,2)  (1,3)  (1,4)  (1,5)
   (2,1)  (2,2)  (2,3)  (2,4)  (2,5)
   (3,1)  (3,2)  (3,3)  (3,4)  (3,5)

   2-dimensional arrays are stored by column. So in the above example, array element (1,2) will follow element (3,1).
Band matrices.  For let us just deal with square banded matrices.  from Lapack docs:
Normally:
!>          AB is DOUBLE PRECISION array, dimension (LDAB,N)
!>          On entry, the upper or lower triangle of the symmetric band
!>          matrix A, stored in the first KD+1 rows of the array.  The
!>          j-th column of A is stored in the j-th column of the array AB
!>          as follows:
!>          if UPLO = 'U', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;
!>          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).
!>          See below for further details.
!>
!>          On exit, if INFO = 0, the triangular factor U or L from the
!>          Cholesky factorization A = U**T*U or A = L*L**T of the band
!>          matrix A, in the same storage format as A.
!>
!>  The band storage scheme is illustrated by the following example, when
!>  N = 6, KD = 2, and UPLO = 'U':
!>
!>  On entry:                       On exit:
!>
!>      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
!>      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
!>     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
!>
!>  Similarly, if UPLO = 'L' the format of A is as follows:
!>
!>  On entry:                       On exit:
!>
!>     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
!>     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
!>     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
!>
!>  Array elements marked * are not used by the routine.
!> 


!>          On entry, the matrix A in band storage, in rows KL+1 to
!>          2*KL+KU+1; rows 1 to KL of the array need not be set.
!>          The j-th column of A is stored in the j-th column of the
!>          array AB as follows:
!>          AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)
!>          On exit, details of the factorization: U is stored as an
!>          upper triangular band matrix with KL+KU superdiagonals in
!>          rows 1 to KL+KU+1, and the multipliers used during the
!>          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
!>
!>  The band storage scheme is illustrated by the following example, when
!>  M = N = 6, KL = 2, KU = 1:
!>
!>  On entry:                       On exit:
!>
!>      *    *    *    +    +    +       *    *    *   u14  u25  u36
!>      *    *    +    +    +    +       *    *   u13  u24  u35  u46
!>      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
!>     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
!>     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
!>     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
!>
!>  Array elements marked * are not used by the routine; elements marked
!>  + need not be set on entry, but are required by the routine to store
!>  elements of U because of fill-in resulting from the row interchanges.



Design:
    Packer: storage_size(), is_stored(i,j), offset(i,j), stored_row_size(i), stored_col_size(j)
    Shape:  nonzero_row_indexes(j) nonzero_col_indexes(i)
    Symmetry: constrains (i,j)=(j,i) ... if (j,i) is not stored return (i,j) instread of zero.
